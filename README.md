# networking_project
Final project for CSCI 420A Networking at Houghton College

Project was done under the guidance/help of Kevin Veloso (cousin).

  The goal of this project was to utilize the knowledge of both networking concepts and python to create a network. The medium of this network is the air, and sounds represent 1s bits. The objective of the project was to make the communication between two machines to be possible without the usage of the common forms of networks, such as Ethernet or IEEE 802.11.
  The main concept of how the network will function is based on a machine that will make the sound via speaker, and the other will receive that sound via microphone and interpret by decoding what the message is and who is it directed to. One protocol used for this project was the idea that when one machine talks, the other must listen. Both cannot occur at the same time. The same used to happen in the early ages of Internet when computers communicated over the Ethernet with a shared communication link. 
  For this project, 3 layers of the OSI Model were implemented: Physical Layer, Data Link Layer, and Network Layer. The physical layer by definition is concerned with transnmitting raw bits over a communication link. As an example, for wireless communication, it is generally used radio or microwave frequencies. In this project's case, the medium is the sound waves through the air. The physical layer initiates the Data Link Layer (here we can see an example of the networking concept of layered networks) and it has 3 main functions that perform its tasks. A manager function, receive function, and send function. The send function first splits the message into 8 bits messages since this is the size of 1 byte, and each packet has 1 byte. After that, the IP address and data are encapsulated into a packet that has one control bit in each end. For the receive function, the function listens, detects transmission by the volume being louder than the threshold, and sends that to the buffer, as it starts off the manager function. It makes sure that the buffer is not overfilled by many bits representing one by deleting the excess of bits given that the beep sound is continuous for a couple of milliseconds. Finally, it adds zeros between the noises and hands the message to the Data Link Layer. Following, the Data Link Layer by definition deals with properly handling frames. In this project's case, this is done with the usage of 4 functions (handle_message, validate_bits, validate_control_bits, and validate_message_length). The concept of layered network structure can be noted by the intiation of the network layer in the beginning of the code. Previously, the physical layer also initiates the Data Link Layer and sends to it the message that it has collected for the handle_message function perform its action. Getting to the Data Link Layer, it initiates the MACHINE_B's network layer, which it has the IP address of 01. Then, the message received from the Physical Layer goes through the process of validating the message. There are 3 validations that must pass through in order for the message to be validated. For the validate_bits, it makes sure that only 1s and 0s are in the message. For the validate_control_bits, it makes sure that the beginning and the end must have a 1. This is due both because this is part of the protocol that this network operates upon, and also because this is a form of the network to encapsulate the packets as it has a control-ip-data-control format. Finally, the last validation is the validate_message_length, which makes sure that the message length is 12 bits long. If any of these fail, the message is not validated. In case the message is validated, the Data Link Layer sends the message and the IP address separately to the Network Layer. When it comes to the Network Layer, since it is concerned with routing, if the IP is for the MACHINE_B, as it was initiated from the Data Link, then it says the message successfully reached its destination. 
  Overall, I found that it is really difficult to have two machines communicate with sound. First of all, the hardware sometimes does not work properly, therefore, the microphone does not get the sound really well. Not only that, but it was really difficult to discern 1s and 0s. Originally, this was done with the help of timestamps, which then 0s were added to the message in their supposed correct places. However, this is not the best way to do this since, as an example, the microphone could detect a noise that was not supposed to be a beep, while working with timestamps is also difficult to handle. In class, a classmate mentioned that I could try to differentiate 1s and 0s by having different tones for each with different pitches, however, I was unable to find a way to get this concept to work, and would need more time to apply this idea.

References: 
https://stackoverflow.com/questions/70872076/opening-wav-from-url-in-python
https://book.systemsapproach.org/ Computer Networks: A Systems Approach book used for CSCI 420A Networking class at Houghton

